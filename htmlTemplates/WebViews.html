<html>
 <head>
  <title>__TITLE__</title>
  <meta name="viewport" content="initial-scale=1.0; maximum-scale=1.0; user-scalable=0;"/>
  <meta http-equiv="X-UA-Compatible" content="IE=edge" /> <!-- for IE CSS compatibility -->
  
  <link href="/scr/css/WebViews.css" rel="stylesheet" type="text/css" />

  <script type="text/javascript" src="/scr/js/jquery-1.8.0.min.js"></script>
  <script type="text/javascript" src="/scr/js/jquery-ui-1.8.23.custom.min.js"></script>
                                 <!-- default custom jquery-ui that contains everything -->
  
  <script type="text/javascript" src="/scr/js/spin.min.js"></script>
  <script type="text/javascript" src="/scr/js/WebViews.js"></script> <!-- requires jQuery -->
  
__LINKSANDSCRIPTS__
 </head>

<script type="text/javascript"> <!--
var console; // on IE, console is undefined, so we define it to ignore any logs (which otherwise cause an error)
if (typeof console == 'undefined') {
  console = { log: function () {}
            , error: function () {} // ignore error. We could also replace body with the message, stopping
            }                       // webviews, but that might be a bit drastic.
}

var debugging = __DEBUG__;
//var debugging = true;
//var debugging = false;

//var drawingViewTree = true;
var drawingViewTree = false;

// automatically send random commands for testing
//var sendingRandomCommands = true;
var sendingRandomCommands = false;

//var autoRefresh = true;
var autoRefresh = false;

// for easily setting a breakpoint in the move operation
function breakpointCheck() {
}

var xmlhttp;

var commandQueue = '';
var requestId = 0;

var focusedElementId = '';

var timer;

$(document).ready(function(){
	initCheckHash();
  init();
});

function init() {
	var rva = getRootViewAndArgs()
  
  queueCommand('Init "'+rva.rootView+'" '+showHaskellArgs(rva.args));
}

// For hash events, we could also use http://benalman.com/projects/jquery-hashchange-plugin/, but it's more complex
// and does not seem to be maintained regularly. This simple though maybe slightly less efficient solution will always work.
var currentHash;

function initCheckHash() {
	currentHash = window.location.hash;
	setInterval("checkHash()", 200);  
}

function checkHash() {
  if (window.location.hash != currentHash) {
  	currentHash = window.location.hash;
  	hashUpdate();
  }	
}

function hashUpdate() {
  var rva = getRootViewAndArgs()
  queueCommand('HashUpdate "'+rva.rootView+'" '+showHaskellArgs(rva.args));
}

function getRootViewAndArgs() {
  // split url:  http:webviews.somewhere.com/#rootView/../pathn&arg0=val0&arg1=val1&..&argm=valm
  // only first path element of hash is used (rootView) probably in the future we will allow full paths
  var hash = window.location.hash.slice(1); // get rid of # (will not give error when hash is "")
      // parse url to rootview and [(String,String)]
 
  var firstArgIx = hash.indexOf('&');
  var pathStr = firstArgIx < 0 ? hash : hash.slice(0, firstArgIx); 
  
  dlog('path '+pathStr+'   args '+argsStr);

  var pathElts = pathStr.split('/');
  var rootView = pathElts.length == 0 ? '' : pathElts[0];
  
  var args = new Array()
  if (firstArgIx >= 0) { // if we have a '&'
  	var argsStr = hash.slice(firstArgIx+1);
    var argStrs = argsStr.split('&');
    for (var i=0; i<argStrs.length; i++) {
     	var nameValue = argStrs[i];
      var eqIx = nameValue.indexOf('=');
      var name = eqIx < 0 ? nameValue : nameValue.slice(0, eqIx); 
      var value = eqIx < 0 ? '' : nameValue.slice(eqIx+1);
     	args.push({"name": name, "value": value});
    }
  }
  return { "rootView": rootView, "args": args };
}

// todo: escape args
function setRootViewAndArgs(rootView, args) {
  var newHash = '#'+rootView;
	for (var i=0; i<args.length; i++) {
  	newHash += '&' + args[i].name + '=' + args[i].value;
  }
  window.location.hash = newHash;
}

function setHashArg(name, value) {
	var rva = getRootViewAndArgs();
  setRootViewAndArgs(rva.rootView, setArg(rva.args, name, value));
}

// Sets argument name to value in args, or adds name=value. Array args is updated as well as returned.
function setArg(args, name, value) {
	var isSet = false;
	for (var i=0; i<args.length; i++) {
		if (args[i].name==name) {
			args[i].value = value;
			isSet = true;
			break;
		}
	}
	if (!isSet)
		args.push({"name": name, "value": value});
	return args;
}

function showHaskellArgs(args) {
	var haskellStrs = new Array();
	for (var i=0; i<args.length; i++)
	   haskellStrs.push('("'+args[i].name+'","'+args[i].value+'")');
	
	return '['+haskellStrs.join(',')+']';
}

function startRefreshTimer() {
	if (autoRefresh) {
		setRefreshTimer(10*1000);
  }
}

/* Don't let non-fatal errors produce an alert when debugging is turned off */
function wvError(message) {
  if (debugging)
    alert(message);
  else
  if (typeof console != 'undefined') // on IE, without debug on, console is undefined
    console.error(message);          // so we ignore the error altogether
}

// TODO: what do we do with fatal errors when there is no console?

function dlog(message) {
  if (debugging && typeof console != 'undefined') // on IE, without debug on, console is undefined
    console.log(message);
}

function setRefreshTimer(ms) {  
	timer = setTimeout('refresh()',ms);
}


function stopRefreshTimer() {
	clearTimeout(timer);
}

function refresh() {
    queueCommand('Refresh');
    startRefreshTimer();
}

/* Obsolete comment:
   For text fields, we just register that they have changed and send them with
   the queue after the first editing operation. Otherwise, when editing a text field and then
   clicking on eg. a radio button generates a server event for the text edit, which causes
   the radiobutton event to get lost. Better would be to remember the exact mouse position and
   generate the event again after the text edit has been handled. Now, if the text edit causes
   disabling and or restructuring of the interface, edit events will be sent which make no
   sense. By checking if the element that receives the event is still in the view structure
   after the text edit has been handled, and that it has not been disabled, we can cover for
   most problematic situations.
*/

function escape(arg) {
	var result = '';
  for (var i = 0; i < arg.length; i++) {
	  if (arg.charAt(i) == '"')
      result += '\\"';
    else if (arg.charAt(i) == '\n')
      result += '\\n';
    else
      result += arg.charAt(i);
  }
  return result;
}

function addCommand(command) {
	commandQueue = commandQueue + (commandQueue != '' ? ',' : '') + command;
} // add command to queue, and if queue was not empty, put a comma in front


var xmlhttp;

// TODO we don't want empty commands sent to server
function queueCommand(command) {
	if (command != '') addCommand(command);

  stopRefreshTimer(); // don't want auto refresh while waiting for results

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
  xmlhttp=null;
  if (window.XMLHttpRequest) {
	  // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
  else if (window.ActiveXObject) {
	  // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
  if (xmlhttp!=null) {
	  xmlhttp.onreadystatechange=state_ChangeWithErrorHandler;
    xmlhttp.open("GET",'/handle?requestId='+requestId+'&commands=Commands ['+commandQueue+']',true);
    dlog("Sent request with id: "+requestId);
    requestId ++;
    xmlhttp.send(null); // commands in commandQueue are already separated by commmas
    commandQueue = '';
  }
  else {
	  alert("Your browser does not support XMLHTTP.");
  }
}

/*
// tricky to do these as regular commands in the command queue.
function authenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'authenticate',true);
  xmlhttp.send(null);
}

function unauthenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'unauthenticate',true);
  xmlhttp.send(null);
}
*/

function state_ChangeWithErrorHandler() {
	if (window.ActiveXObject) // on IE we don't need to do anything, as errors thrown by state_Change will be caught by debugger
		state_Change();
	else // on Firefox, errors are lost, so we need to catch and display them with a try catch block
		try {
			state_Change();
		} catch (e) {
		  console.error("Javascript error (not reported by firebug)"+
				            (typeof e.lineNumber=='undefined'?", no linenumber available:":" on line "+e.lineNumber)+"\n"+
				            e.message);
		}
}

function state_Change() {
	if (xmlhttp.readyState==4) {// 4 = "loaded"
  	if (xmlhttp.status==200) {// 200 = "OK"
	    var receivedUpdates = document.getElementById('receivedUpdates');
  	  receivedUpdates.innerHTML=xmlhttp.responseText;
  		
  		var updates = document.getElementById('updates');
      // getElementById seems to trigger parsing the responseText
  		// after this, firstChild has a value, while it is null before
    	// newRendering.firstChild;
  
  	  var responseId = updates.getAttribute('responseId');
	  	dlog("Received response with id: "+responseId);
	  	
   	  if (commandQueue != '') {
   		  dlog('sending queue');
        queueCommand('');
      }
	  	
   	  var moves = new Array();
      var scripts = new Array();
   	  
   		// process all the updates from the server
   		while (updates.firstChild) {
   			updateTree( updates.firstChild, moves, scripts);
        updates.removeChild(updates.firstChild);
      }

   		processPendingMoves(moves);
      removeChildrenById("parking"); // clean any parked webnodes

   		processPendingScripts(scripts); // execute scripts only after the dom tree is correct
   		// TODO: we could optimize this a bit by separating the scripts from the updates in the server communication
   		
   		clearSpinners();
   		
   		dlog('Nr of remaining new nodes '+document.getElementById('new').childNodes.length);
   		if (document.getElementById('new').childNodes.length !=0)
   			wvError("Error, new node list not empty");
      
   		if (drawingViewTree)
        drawViewTree();


      restoreFocus();

//    $("[class='tabbed']").tabs(); // register tabbed views
//    $("[class='draggable']").draggable({refreshPositions: true});
//    $("[class='sortable']").draggable({refreshPositions: true});

/*  uncomment this for sortable hLists
 $(function() {
 $(".hList").disableSelection();
 $(".vList").disableSelection();

$(".hList").sortable({connectWith: '.vList, .hList'});
$(".vList").sortable({connectWith: '.vList, .hList'});
});
*/
      $(".ellipsis").ellipsis(); // need to do this after dom is built, so we can't do it in the jsScripts
                                 // but since ellipsis only executes when necessary, this is no big deal.
      
      // start refresh timer again
      if (commandQueue == '') // only if command handling did not queue any new commands
        if (sendingRandomCommands)
          sendRandomCommand();
        else
          startRefreshTimer();
    }
    else { // xmlhttp.status!=200
      console.error("Problem retrieving data:" + xmlhttp.statusText);
    }
  } // no action if xmlhttp.readyState!=4
}

function updateTree(update, moves, scripts) {
	var op = update.getAttribute('op');
 
  if (op === 'special') { // used for trying out commands in a running WebView
	  var targetId = update.getAttribute('targetId');
    var newChild = update.childNodes[0];
    dlog("special"+commandQueue);

    var parking = document.getElementById("parking");
    var ther2 = document.getElementById("input11");
    var ther3 = document.getElementById("pigview15");
  
    //parking.appendChild(ther3);

    var oldChild = document.getElementById(targetId);  
    var parent = oldChild.parentNode;    
    parent.replaceChild(newChild,oldChild);

    var newwrong2 = document.getElementById("input111");
    var parentr2 = newwrong2.parentNode;    
    parentr2.replaceChild(ther2,newwrong2); // Note: old and new seem reversed (but are ok)

    var newwrong3 = document.getElementById("pigview115");
    var parentr3 = newwrong3.parentNode;    
    parentr3.replaceChild(ther3,newwrong3); // Note: old and new seem reversed (but are ok)

    focusedElementId = "radio122button0";
    dlog("restoring focus to "+focusedElementId);
    var focusedElement = document.getElementById(focusedElementId);
    if (focusedElement != null)
      focusedElement.focus();
    else
      dlog("failed");
    dlog ("end of special");
  }
  else if (op === 'exception') {
	  var text = update.getAttribute('text');
    sendingRandomCommands = false;
    autoRefresh = false;
    wvError(text);
    init();
  }
  else if (op === 'dialog') {
	  dialogContent = $(update).find('.contents').html();
	  var buttons = $.map( $(update).find('.button'), function(b) {return {name: $(b).attr('name'), command: $(b).attr('command')} } );
	  showDialog(dialogContent, buttons);
  } 
  else if (op === 'authenticate') {
	  authenticate();
  } 
  else if (op === 'new') {
	  var newChild = update.childNodes[0];

    var newElts = document.getElementById('new');
    newElts.appendChild(newChild);
  }
  else if (op === 'eval') {
    var scriptTxt = $(update).text() 
    // don't use childNodes[0].data, since on Windows Firefox, the text is split in 1024 sized blocks
    // also .textContent doesn't work on IE and .innerText not on Firefox, so we use jQuery's .text()
    scripts.push(scriptTxt);
  }
  else if (op === 'move') {
	  var srcId = update.getAttribute('src');
    var dstId = update.getAttribute('dst');
    srcElt = document.getElementById(srcId);
    dstElt = document.getElementById(dstId);
    if (srcElt && dstElt) { // we don't move here, but simply queue each move (see processPending moves). 
      moves.push({sourceId: srcId, sourceElt: srcElt, destinationId: dstId, destinationParent: dstElt.parentNode,
      	          destinationIndex: $(dstElt.parentNode).contents().index( dstElt ) });
      dlog('Queue move '+srcId+' '+dstId);
    }
    else
    	wvError("move source or destination is null. src("+srcId+"):"+srcElt+", dst("+dstId+"):"+dstElt)
  }
  else wvError ('Unknown command: '+op); 
}

/*
 * Moves are a two-phase process because otherwise move cycles (eg. [a->b, b->a]) cannot be handled.
 * To account for a destination that may have been moved, we first encode all destinations by parent element and child index,
 * which remain correct even if the destination node itself is moved (this is done in updateTree). 
 * For each source node that is moved in processPendingMoves, we need to add an anonymous stub, to keep the indices in the
 * encoded destinations valid. This is not necessary if the source is new (since it can't be a destination then), or if 
 * the source is already parked (since then the destination move has already taken place).
 * The server incrementality algorithm will guarantee that no anonymous stubs remain in the final tree.
 */
function processPendingMoves(moves) {
  var newNodesElt = document.getElementById('new');
  var parkingElt = document.getElementById('parking');
  
  for (var i=0; i<moves.length; i++) {
    var move = moves[i]
    
    breakpointCheck();
   
    dlog('Processing move of ' + move.sourceId + ' to old location of ' + move.destinationId);;
    
    // If the source element is not in newNode, we replace it with an anonymous stub, so any subsequent moves to this element
    // (encoded by parent + index) will still succeed.
    if (move.sourceElt.parentNode != newNodesElt && move.sourceElt.parentNode != parkingElt) { 
      var anonymousStub = document.createElement('span');
      move.sourceElt.parentNode.replaceChild( anonymousStub, move.sourceElt ); 
    }
    
    var destElt = move.destinationParent.childNodes[ move.destinationIndex ]; // this will either be the element or an anonymous stub
    move.destinationParent.replaceChild( move.sourceElt, destElt );
    parkingElt.appendChild(destElt); // this also parks some stubs, but that's no problem
  }
}

// Because eval may change local parameters, we put _X_ after the identifiers.
function processPendingScripts(scripts_X_) {
	for (var i_X_=0; i_X_<scripts_X_.length; i_X_++) {    
    var scriptLines_X_ = scripts_X_[i_X_].split('\n');
    var scriptLine_X_;
    try {
      for (var j_X_=0; j_X_<scriptLines_X_.length; j_X_++) {
        scriptLine_X_ = scriptLines_X_[j_X_];
        dlog('Eval ('+i_X_+'.'+j_X_+'/'+scripts_X_.length+'): ',scriptLine_X_);
        eval(scriptLine_X_);
      }
    }
    catch (e) {
      wvError("Error in dynamic script.\nLine: "+scriptLine_X_+"\n\n"+e+"\n\nSee console log for more information."); // important, so alert (doesn't seem to work)
      console.error("Error in script: "+e); // log error, so we can see when the problem occurs
                                            // Firebug output may be a bit confusing, stating that scripts_X_ is undefined
    }
	}
}

function select(path, node) {
	var step = path.firstChild;
  if (!step)
    return node;
  else {
	  path.removeChild(step);
    var childNr = parseInt( step.getAttribute('childNr') ); 
    var child = node.childNodes[childNr];
    return (select (path, child));
  }
}

function drawViewTree() {
	removeChildrenById("viewTree");    
  drawViewTreeElt('',document.getElementById('root'));
}

function drawViewTreeElt(indent, elt) {
	if (elt.id) draw(indent+elt.id+'<br/>');
  for (var i=0; i < elt.childNodes.length; i++)
    drawViewTreeElt(indent+  (elt.id ? '&nbsp;&nbsp;&nbsp;' : ''), elt.childNodes[i]);
}

function draw(str) {
	document.getElementById('viewTree').innerHTML+=str
}

function removeChildrenById(id) {
	removeChildren(document.getElementById(id));
}

function removeChildren(elt) {
	while (elt.firstChild)
    elt.removeChild(elt.firstChild);
}

function sendRandomCommand() {
	dlog("random command");
  /* allButtons = $("button");
  i = Math.floor( Math.random()*allButtons.length);
  
  randomButton = $("button:eq("+i+")").attr('id');
  randomCommand = "ButtonC ("+randomButton+")";
*/
  allRadios= $("input[type='radio']");
  i = Math.floor( Math.random()*allRadios.length);
  
  randomRadioName = $("input[type='radio']:eq("+i+")").attr('name');
  radioButtons = $("input[type='radio'][name="+randomRadioName+"]");

  alert('Radio '+randomRadioName+radioButtons+' '+radioButtons.length);
// TODO why do we get this alert twice?

//dlog(randomCommand);
  //queueCommand(randomCommand);
}

/* restore focus to element with id focusedElementId
   NOTE: because focus() scrolls to the focused element, we save and restore scrollbar
   positions of all elements up to the the html element. This also fixes a bug, where after
   a focus() call, all other UI events (such as a button click) disappear.
*/
function restoreFocus() {
  if (!focusedElementId) 
    dlog("No previously focused element");
  else 
    dlog("restoring focus to "+focusedElementId);
    var focusedElement = document.getElementById(focusedElementId);
    if (focusedElement == null)
      dlog("Element no longer exists");
    else {
      var scrollXPositions = new Array();
      var scrollYPositions = new Array();
     
      var $elt = $(focusedElement);
      while (!$elt.is('html')) { // save all scrollbar positions
//       dlog($elt.prop('tagName')+' '+ $elt.scrollTop());
        scrollXPositions.push($elt.scrollLeft());
        scrollYPositions.push($elt.scrollTop());
        $elt = $elt.parent();
      }
  
      // set focus to focusedElement, but temporarily disable its onfocus handler, since
      // the focus is not new. 
      var focusHandler =focusedElement.onfocus;
      focusedElement.onfocus = null;
      focusedElement.focus();
      focusedElement.onfocus = focusHandler;
  
      $elt = $(focusedElement);
      while (!$elt.is('html')) { // restore all scrollbar positions
        $elt.scrollLeft( scrollXPositions.shift() );
        $elt.scrollTop( scrollYPositions.shift() );
//        dlog($elt.prop('tagName')+' '+ $elt.scrollTop());
        $elt = $elt.parent();
      }
    }
}

// Dynamic scripting

function textFieldChanged(textFieldId) {
	value = escape(document.getElementById(textFieldId).value);
  queueCommand ('SetC '+textFieldId+' "'+value+'"');
  dlog('textFieldChanged '+value);
}

function elementGotFocus(id) {
	dlog('element '+id+' got focus');
  focusedElementId = id;
}  

// constructors for script nodes associated with each webview
// Note: the viewId's here are Haskell ViewId's (eg. ViewId [path])
function ButtonScript(viewId) {
    this.viewId = viewId;
    this.onFocus = function () {elementGotFocus(viewId)};
    this.onClick = function () {queueCommand('ButtonC '+viewId)};
}

function TextViewScript(viewId) {
    this.viewId = viewId;
    this.onSubmit = function () {dlog('onSubmit');textFieldChanged(viewId);queueCommand('SubmitC '+ viewId)}; 
    // only called for edit actions on text fields (not areas)
    // the textFieldChanged will cause a double update on the textfield, since the blur will also fire
    // (unless the submit causes an update that removes the textfield). Superfluous happen all the time
    // though, so this should not create a problem. TODO: maybe cache the textfield value and only send it on a change
    
    this.onFocus  = function () {dlog('onFocus');elementGotFocus(viewId)};
    this.onBlur   = function () {dlog('onBlur');textFieldChanged(viewId)};
    this.onKeyUp  = function () {};
}

function SelectScript(viewId) {
  this.viewId = viewId;
  this.onFocus  = function () {elementGotFocus(viewId)};
  this.onChange = function () {var i = document.getElementById(viewId).selectedIndex; queueCommand('SetC '+viewId+' "'+i+'"')};
}


--></script>

<body style="padding:0px; margin:0px">
<div id="viewTree" style="visibility:hidden"></div>
<div id="root"><div id="1"></div></div>
<div id="new" style="visibility:hidden"></div>
<div id="parking" style="visibility:hidden"></div>
<div id="receivedUpdates" style="visibility:hidden"></div>
</body> </html>
