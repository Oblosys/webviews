<!DOCTYPE HTML>
<html> <head>
<title>Piglet 2.0</title>
<link href="scr/WebViews.css" rel="stylesheet" type="text/css" />

<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.0/jquery.min.js"></script>
<script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/jquery-ui.min.js"></script>
 
</head>

<script type="text/javascript">
<!--// < this comment keeps emacs from thinking the whole block is a comment
//var debugging = true;
var debugging = false;

//var drawingViewTree = true;
var drawingViewTree = false;

//var sendingCommands = true;
var sendingCommands = false;

var autoRefresh = true;
//var autoRefresh = false;

// for easily setting a breakpoint in the move operation
function breakpointCheck()
{
}

var xmlhttp;

var commandQueue = '';

var focusedElementId = '';

var timer;

$(document).ready(function(){
});

function init()
{ queueCommand('Init');
  refresh();
}

function startRefreshTimer()
{ if (autoRefresh)
  { setRefreshTimer(1000);
  }
}


function debug(message)
{
  if (debugging)
    document.getElementById('debugMessage').innerHTML=message;
}

function debugAdd(message)
{
  if (debugging)
    debug (message + '<br></br>' + document.getElementById('debugMessage').innerHTML);
}

function setRefreshTimer(ms)
{  
    timer = setTimeout('refresh()',ms);
}


function stopRefreshTimer()
{ clearTimeout(timer);
}

function refresh()
{
    queueCommand('Refresh');
    startRefreshTimer();
}

/* Obsolete comment:
   For text fields, we just register that they have changed and send them with
   the queue after the first editing operation. Otherwise, when editing a text field and then
   clicking on eg. a radio button generates a server event for the text edit, which causes
   the radiobutton event to get lost. Better would be to remember the exact mouse position and
   generate the event again after the text edit has been handled. Now, if the text edit causes
   disabling and or restructuring of the interface, edit events will be sent which make no
   sense. By checking if the element that receives the event is still in the view structure
   after the text edit has been handled, and that it has not been disabled, we can cover for
   most problematic situations.
*/

function escape(arg)
{ var result = '';
  for (var i = 0; i < arg.length; i++)
  { if (arg[i] == '"')
      result += '\\"';
    else if (arg[i] == '\n')
      result += '\\n';
    else
      result += arg[i];
  }
  return result;
}

function textFieldChanged(textFieldId)
{ value = escape(document.getElementById(textFieldId).value);
  queueCommand ('SetC ('+textFieldId+') "'+value+'"');
  debugAdd('textFieldChanged '+value);
}

function elementGotFocus(id)
{ debugAdd('element '+id+' has focus');
  focusedElementId = id;
}  

function addCommand(command)
{ commandQueue = commandQueue + (commandQueue != '' ? ',' : '') + command;
} // add command to queue, and if queue was not empty, put a comma in front


var xmlhttp;

// TODO we don't want empty commands sent to server
function queueCommand(command)
{ if (command != '') addCommand(command);

  stopRefreshTimer(); // don't want auto refresh while waiting for results

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
  xmlhttp=null;
  if (window.XMLHttpRequest)
  { // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
  else if (window.ActiveXObject)
  { // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
  if (xmlhttp!=null)
  { 
    { xmlhttp.onreadystatechange=state_Change;
      xmlhttp.open("GET",'handle?commands=Commands ['+commandQueue+']',true);
      xmlhttp.send(null); // commands in commandQueue are already separated by commmas
      commandQueue = '';
    }
  }
  else
  { alert("Your browser does not support XMLHTTP.");
  }
}

/*
// tricky to do these as regular commands in the command queue.
function authenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'authenticate',true);
  xmlhttp.send(null);
}

function unauthenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'unauthenticate',true);
  xmlhttp.send(null);
}
*/

function state_Change()
{
if (xmlhttp.readyState==4)
  {// 4 = "loaded"
  if (xmlhttp.status==200)
    {// 200 = "OK"

    debugAdd("received");
    var receivedUpdates = document.getElementById('receivedUpdates');
    receivedUpdates.innerHTML=xmlhttp.responseText;
    
    
    if (commandQueue != '')
    { debugAdd('sending queue');
      queueCommand('');
    }
    
   
    var updates = document.getElementById('updates');
    // getElementById seems to trigger parsing the responseText
    // after this, firstChild has a value, while it is null before
    // newRendering.firstChild;
    
   // process all the updates from the server
   while (updates.firstChild)
    { updateTree( updates.firstChild );
    ; updates.removeChild(updates.firstChild);
    }

   if (drawingViewTree)
     drawViewTree();

    removeChildrenById("parking"); // clean any parked webnodes

    // restore focus
    debugAdd("restoring focus to "+focusedElementId);
    var focusedElement = document.getElementById(focusedElementId);
    if (focusedElement != null)
      focusedElement.focus();
    else
      debugAdd("failed");

//    $("[class='tabbed']").tabs(); // register tabbed views
//    $("[class='draggable']").draggable({refreshPositions: true});
//    $("[class='sortable']").draggable({refreshPositions: true});

/*  uncomment this for sortable hLists
 $(function() {
 $(".hList").disableSelection();
 $(".vList").disableSelection();

$(".hList").sortable({connectWith: '.vList, .hList'});
$(".vList").sortable({connectWith: '.vList, .hList'});
});
*/


    // start refresh timer again
    if (commandQueue == '') // only if command handling did not queue any new commands
      if (sendingCommands)
        sendRandomCommand();
      else
        startRefreshTimer();

  }
  else
    {
    debug("Problem retrieving data:" + xmlhttp.statusText);
//    document.getElementById('status').innerHTML='Server not available.';
    }
  }
}

function updateTree(update)
{ var op = update.getAttribute('op');
 
 if (op === 'replace')
  { var targetId = update.getAttribute('targetId');
    var newChild = update.childNodes[0];
    debugAdd("replace");
    debugAdd(commandQueue);
    
    var oldChild = document.getElementById(targetId);
    
    var parent = oldChild.parentNode;
    
    parent.replaceChild(newChild,oldChild);
  } 
 else if (op === 'special')
  { var targetId = update.getAttribute('targetId');
    var newChild = update.childNodes[0];
    debugAdd("special"+commandQueue);

    var parking = document.getElementById("parking");
    var ther2 = document.getElementById("input11");
    var ther3 = document.getElementById("pigview15");
  
    //parking.appendChild(ther3);



    var oldChild = document.getElementById(targetId);  
    var parent = oldChild.parentNode;    
    parent.replaceChild(newChild,oldChild);

    var newwrong2 = document.getElementById("input111");
    var parentr2 = newwrong2.parentNode;    
    parentr2.replaceChild(ther2,newwrong2); // Note: old and new seem reversed (but are ok)

    var newwrong3 = document.getElementById("pigview115");
    var parentr3 = newwrong3.parentNode;    
    parentr3.replaceChild(ther3,newwrong3); // Note: old and new seem reversed (but are ok)

    focusedElementId = "radio122button0";
    debugAdd("restoring focus to "+focusedElementId);
    var focusedElement = document.getElementById(focusedElementId);
    if (focusedElement != null)
      focusedElement.focus();
    else
      debugAdd("failed");
    debugAdd ("end of special");
  }
 else if (op === 'exception')
  { var text = update.getAttribute('text');
    sendingCommands = false;
    autoRefresh = false;
    alert(text);
    init();
  } 
else if (op === 'alert')
  { var text = update.getAttribute('text');
    if (!sendingCommands)  // don't let dialogs interrupt auto command sequence
      alert(text);
  } 
 else if (op === 'confirm')
  { var text = update.getAttribute('text');
    if (!sendingCommands)  // don't let dialogs interrupt auto command sequence
    {  if (confirm(text))
        queueCommand('ConfirmDialogOk');
    }
    else
      queueCommand('ConfirmDialogOk');
  } 
 else if (op === 'authenticate')
  {  authenticate();
  } 
 else if (op === 'new')
  { var newChild = update.childNodes[0];

    var newElts = document.getElementById('new');
    newElts.appendChild(newChild);
  }
 else if (op === 'move')
  { var srcId = update.getAttribute('src');
    var dstId = update.getAttribute('dst');
    breakpointCheck();
    debugAdd("Moving "+srcId + " to " + dstId);
    srcElt = document.getElementById(srcId);
    dstElt = document.getElementById(dstId);

    if (srcElt && dstElt)
    { parentElt = dstElt.parentNode;

      var parkingElt = document.getElementById('parking');
      parentElt.replaceChild(srcElt,dstElt);

//    parentElt.insertBefore(srcElt,dstElt);
      parkingElt.appendChild(dstElt);
    }
  }
 else alert ('Unknown command: '+op); 
}

function select(path, node)
{ var step = path.firstChild;
  if (!step)
    return node;
  else
    { path.removeChild(step);
      var childNr = parseInt( step.getAttribute('childNr') ); 
      var child = node.childNodes[childNr];
      return (select (path, child));
    }
}

function drawViewTree()
{ removeChildrenById("viewTree");    
     
  drawViewTreeElt('',document.getElementById('root'));
}

function drawViewTreeElt(indent, elt)
{ if (elt.id) draw(indent+elt.id+'<br/>');
  for (var i=0; i < elt.childNodes.length; i++)
    drawViewTreeElt(indent+  (elt.id ? '&nbsp;&nbsp;&nbsp;' : ''), elt.childNodes[i]);
}

function draw(str)
{ document.getElementById('viewTree').innerHTML+=str
}

function removeChildrenById(id)
{ removeChildren(document.getElementById(id));
}

function removeChildren(elt)
{ while (elt.firstChild)
    elt.removeChild(elt.firstChild);
}

function sendRandomCommand()
{ debugAdd("random command");
  /* allButtons = $("button");
  i = Math.floor( Math.random()*allButtons.length);
  
  randomButton = $("button:eq("+i+")").attr('id');
  randomCommand = "ButtonC ("+randomButton+")";
*/
  allRadios= $("input[type='radio']");
  i = Math.floor( Math.random()*allRadios.length);
  
  randomRadioName = $("input[type='radio']:eq("+i+")").attr('name');
  radioButtons = $("input[type='radio'][name="+randomRadioName+"]");

  alert('Radio '+randomRadioName+radioButtons+' '+radioButtons.length);
// TODO why do we get this alert twice?

//debugAdd(randomCommand);
  //queueCommand(randomCommand);
}

-->
/* for drag to float, add min-height to ul
   and make sure connectWith is not set on both hlist and vlist, or
   drag will be buggy
*/
$(function() {
 $(".vList").disableSelection();

 $(".hList").disableSelection();

 $(".hList").sortable({connectWith: '.hList'});
$(".vList").sortable({connectWith: '.vList'});
});
 

/*tables are trickier, as the dragged object is either a tr or a td, which requires some
changes when dropping or hovering

still causes bugs:
$(".vList").sortable({connectWith: '.vList, .hList'});

*/	
</script>
<style type="text/css">
.vList { list-style-type: none; margin: 0; padding: 0 }
.vList li {margin: 3px 3px 3px 0; padding: 1px; float: none; }
.hList { list-style-type: none; margin: 0; padding: 0; min-height: 600px; }
.hList li {margin: 3px 3px 3px 0; padding: 1px; float: left; width: 300px;}
.hList li:first-child { clear: left }
</style>

<body onload="javascript: init();" style="padding:0px; margin:0px">
<!--
<ul class="vList">
<li style = "background: red; margin: 10px; width:40px">een</li>
<li style = "left; background: blue; margin: 10px; width:40px">twee</li>
<li style = "left; background: black; margin: 10px; width:40px">drie</li>
</ul>

<ul class="hList">
<li style = "background: red; margin: 10px;">aaa</li>
<li style = "left; background: blue; margin: 10px;">bbbbbb</li>
<li style = "left; background: yellow; margin: 10px;">
 <ul class="vList">
 <li style = "background: red; margin: 10px; width:40px">een</li>
 <li style = "left; background: blue; margin: 10px; width:40px">twee</li>
 <li style = "left; background: black; margin: 10px; width:40px">drie</li>
 </ul>
</li>
</ul>
-->
<!-- TODO: left? forgotten float? -->

<!--
<div onclick="sendingCommands = true">Test</div> -->
<!--
<table cellpadding="0" style="border-collapse: collapse;">
  <tr><span class="draggable"> <td>zaza</td></span><td>bla</td></tr>
</table>
-->
<!--
<div class="tabbed" style="background-color: red;">
    <ul>
        <li><a href="#fragment-1">One</a></li>
        <li><a href="#fragment-2">Two</a></li>
        <li><a href="#fragment-3">Three</a></li>
    </ul>
    <div id="fragment-1" style="background-color: red;">
een
    </div>
    <div id="fragment-2">
twee
    </div>
    <div id="fragment-3">
drie
    </div>
</div>
-->
<!-- <button onClick="debugAdd('click')" onfocus="debugAdd('focus')">click</button> -->
<!-- <div style="border:solid; border-width:1px; margin:0px"> -->
<div id="viewTree"></div>
<div id="root"><div id="1">Initial root</div></div>
<!-- </div> -->
<!-- Debug: -->
<div style="padding:4px;" id="debugMessage"></div>
<div id="new"></div>
<div id="parking"></div>

<div id="receivedUpdates" style="visibility:hidden; border:solid; border-width:1px; padding:4px; border-color:red;" ></div>
</body> </html>
