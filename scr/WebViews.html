<!DOCTYPE HTML>
<html>
 <head>
  <title>WebViews prototype</title>
  <link href="scr/WebViews.css" rel="stylesheet" type="text/css" />

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js"></script>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.16/jquery-ui.min.js"></script>
  
  <script type="text/javascript" src="scr/spin.min.js"></script>
  <script type="text/javascript" src="scr/util.js"></script> <!-- requires jQuery -->
 </head>

<script type="text/javascript"> <!--

//var debugging = true;
var debugging = false;

//var drawingViewTree = true;
var drawingViewTree = false;

// automatically send random commands for testing
//var sendingRandomCommands = true;
var sendingRandomCommands = false;

var autoRefresh = true;
//var autoRefresh = false;

// for easily setting a breakpoint in the move operation
function breakpointCheck() {
}

var xmlhttp;

var commandQueue = '';
var requestId = 0;

var focusedElementId = '';

var timer;

$(document).ready(function(){
});

function init() {
  var path = (document.location.href.split('/'))[3];
  queueCommand('Init "'+path+'"');
}

function startRefreshTimer() {
	if (autoRefresh) {
		setRefreshTimer(1000);
  }
}

function dlog(message) {
  if (debugging)
    console.log(message);
}

function setRefreshTimer(ms) {  
	timer = setTimeout('refresh()',ms);
}


function stopRefreshTimer() {
	clearTimeout(timer);
}

function refresh() {
    queueCommand('Refresh');
    startRefreshTimer();
}

/* Obsolete comment:
   For text fields, we just register that they have changed and send them with
   the queue after the first editing operation. Otherwise, when editing a text field and then
   clicking on eg. a radio button generates a server event for the text edit, which causes
   the radiobutton event to get lost. Better would be to remember the exact mouse position and
   generate the event again after the text edit has been handled. Now, if the text edit causes
   disabling and or restructuring of the interface, edit events will be sent which make no
   sense. By checking if the element that receives the event is still in the view structure
   after the text edit has been handled, and that it has not been disabled, we can cover for
   most problematic situations.
*/

function escape(arg) {
	var result = '';
  for (var i = 0; i < arg.length; i++) {
	  if (arg[i] == '"')
      result += '\\"';
    else if (arg[i] == '\n')
      result += '\\n';
    else
      result += arg[i];
  }
  return result;
}

function addCommand(command) {
	commandQueue = commandQueue + (commandQueue != '' ? ',' : '') + command;
} // add command to queue, and if queue was not empty, put a comma in front


var xmlhttp;

// TODO we don't want empty commands sent to server
function queueCommand(command) {
	if (command != '') addCommand(command);

  stopRefreshTimer(); // don't want auto refresh while waiting for results

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
  xmlhttp=null;
  if (window.XMLHttpRequest) {
	  // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
  else if (window.ActiveXObject) {
	  // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
  if (xmlhttp!=null) {
	  xmlhttp.onreadystatechange=state_ChangeWithErrorHandler;
    xmlhttp.open("GET",'handle?requestId='+requestId+'&commands=Commands ['+commandQueue+']',true);
    console.log("Sent request with id: "+requestId);
    requestId ++;
    xmlhttp.send(null); // commands in commandQueue are already separated by commmas
    commandQueue = '';
  }
  else {
	  alert("Your browser does not support XMLHTTP.");
  }
}

/*
// tricky to do these as regular commands in the command queue.
function authenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'authenticate',true);
  xmlhttp.send(null);
}

function unauthenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'unauthenticate',true);
  xmlhttp.send(null);
}
*/

function state_ChangeWithErrorHandler() {
	if (window.ActiveXObject) // on IE we don't need to do anything, as errors thrown by state_Change will be caught by debugger
		state_Change();
	else // on Firefox, errors are lost, so we need to catch and display them with a try catch block
		try {
			state_Change();
		} catch (e) {
		  console.error("Javascript error (not reported by firebug)"+
				            (typeof e.lineNumber=='undefined'?", no linenumber available:":" on line "+e.lineNumber)+"\n"+
				            e.message);
	  	console.error(); // may not always work
		}
}

function state_Change() {
	if (xmlhttp.readyState==4) {// 4 = "loaded"
  	if (xmlhttp.status==200) {// 200 = "OK"
	    var receivedUpdates = document.getElementById('receivedUpdates');
  	  receivedUpdates.innerHTML=xmlhttp.responseText;
  		
  		var updates = document.getElementById('updates');
      // getElementById seems to trigger parsing the responseText
  		// after this, firstChild has a value, while it is null before
    	// newRendering.firstChild;
  
  	  var responseId = updates.getAttribute('responseId');
	  	console.log("Received response with id: "+responseId);
	  	
   	  if (commandQueue != '') {
   		  dlog('sending queue');
        queueCommand('');
      }
	  	
   		// process all the updates from the server
   		while (updates.firstChild) {
   			updateTree( updates.firstChild );
        updates.removeChild(updates.firstChild);
      }
   		
   		clearSpinners();
   		
   		console.log('Nr of remaining new nodes '+document.getElementById('new').childNodes.length);
   		if (document.getElementById('new').childNodes.length !=0)
   			alert("Error, new node list not empty");
      
   		if (drawingViewTree)
        drawViewTree();

      removeChildrenById("parking"); // clean any parked webnodes

      // restore focus
      dlog("restoring focus to "+focusedElementId);
      var focusedElement = document.getElementById(focusedElementId);
      if (focusedElement != null)
        focusedElement.focus();
      else
        dlog("failed");

//    $("[class='tabbed']").tabs(); // register tabbed views
//    $("[class='draggable']").draggable({refreshPositions: true});
//    $("[class='sortable']").draggable({refreshPositions: true});

/*  uncomment this for sortable hLists
 $(function() {
 $(".hList").disableSelection();
 $(".vList").disableSelection();

$(".hList").sortable({connectWith: '.vList, .hList'});
$(".vList").sortable({connectWith: '.vList, .hList'});
});
*/
      // start refresh timer again
      if (commandQueue == '') // only if command handling did not queue any new commands
        if (sendingRandomCommands)
          sendRandomCommand();
        else
          startRefreshTimer();
    }
    else { // xmlhttp.status!=200
      console.error("Problem retrieving data:" + xmlhttp.statusText);
    }
  } // no action if xmlhttp.readyState!=4
}

function updateTree(update) {
	var op = update.getAttribute('op');
 
  if (op === 'special') { // used for trying out commands in a running WebView
	  var targetId = update.getAttribute('targetId');
    var newChild = update.childNodes[0];
    dlog("special"+commandQueue);

    var parking = document.getElementById("parking");
    var ther2 = document.getElementById("input11");
    var ther3 = document.getElementById("pigview15");
  
    //parking.appendChild(ther3);

    var oldChild = document.getElementById(targetId);  
    var parent = oldChild.parentNode;    
    parent.replaceChild(newChild,oldChild);

    var newwrong2 = document.getElementById("input111");
    var parentr2 = newwrong2.parentNode;    
    parentr2.replaceChild(ther2,newwrong2); // Note: old and new seem reversed (but are ok)

    var newwrong3 = document.getElementById("pigview115");
    var parentr3 = newwrong3.parentNode;    
    parentr3.replaceChild(ther3,newwrong3); // Note: old and new seem reversed (but are ok)

    focusedElementId = "radio122button0";
    dlog("restoring focus to "+focusedElementId);
    var focusedElement = document.getElementById(focusedElementId);
    if (focusedElement != null)
      focusedElement.focus();
    else
      dlog("failed");
    dlog ("end of special");
  }
  else if (op === 'exception') {
	  var text = update.getAttribute('text');
    sendingRandomCommands = false;
    autoRefresh = false;
    alert(text);
    init();
  }
  else if (op === 'alert') {
	  var text = update.getAttribute('text');
    if (!sendingRandomCommands)  // don't let dialogs interrupt auto command sequence
      alert(text);
  } 
  else if (op === 'confirm') {
	  var text = update.getAttribute('text');
    if (!sendingRandomCommands) { // don't let dialogs interrupt auto command sequence
      if (confirm(text))
        queueCommand('ConfirmDialogOk');
    }
    else
      queueCommand('ConfirmDialogOk');
  } 
  else if (op === 'authenticate') {
	  authenticate();
  } 
  else if (op === 'new') {
	  var newChild = update.childNodes[0];

    var newElts = document.getElementById('new');
    newElts.appendChild(newChild);
  }
  else if (op === 'move') {
	  var srcId = update.getAttribute('src');
    var dstId = update.getAttribute('dst');
    breakpointCheck();
    dlog("Moving "+srcId + " to " + dstId);
    srcElt = document.getElementById(srcId);
    dstElt = document.getElementById(dstId);

    if (srcElt && dstElt) {
    	parentElt = dstElt.parentNode;

      var parkingElt = document.getElementById('parking');
      parentElt.replaceChild(srcElt,dstElt); // ParentElt.dstElt -> ParentElt.srcElt (note confusing parameter order)

//    parentElt.insertBefore(srcElt,dstElt);
      parkingElt.appendChild(dstElt);
    }
    else
    	console.error("Source or destination is null. src("+srcId+"):"+srcElt+", dst("+dstId+"):"+dstElt)
  }
  else if (op === 'eval') {
	  var scriptTxt = update.textContent; // don't use childNodes[0].data, since on Windows Firefox, the text is split in 1024 sized blocks
    console.log("Evaluate:",scriptTxt);
	  try {
    	eval(scriptTxt);
	  }
	 catch (e) {
		  console.error("Error in script: "+e); // log error, so we can see when the problem occurs 
		  alert("Error in script: "+e); // important, so alert
	  }
  }
  else alert ('Unknown command: '+op); 
}

function select(path, node) {
	var step = path.firstChild;
  if (!step)
    return node;
  else {
	  path.removeChild(step);
    var childNr = parseInt( step.getAttribute('childNr') ); 
    var child = node.childNodes[childNr];
    return (select (path, child));
  }
}

function drawViewTree() {
	removeChildrenById("viewTree");    
  drawViewTreeElt('',document.getElementById('root'));
}

function drawViewTreeElt(indent, elt) {
	if (elt.id) draw(indent+elt.id+'<br/>');
  for (var i=0; i < elt.childNodes.length; i++)
    drawViewTreeElt(indent+  (elt.id ? '&nbsp;&nbsp;&nbsp;' : ''), elt.childNodes[i]);
}

function draw(str) {
	document.getElementById('viewTree').innerHTML+=str
}

function removeChildrenById(id) {
	removeChildren(document.getElementById(id));
}

function removeChildren(elt) {
	while (elt.firstChild)
    elt.removeChild(elt.firstChild);
}

function sendRandomCommand() {
	dlog("random command");
  /* allButtons = $("button");
  i = Math.floor( Math.random()*allButtons.length);
  
  randomButton = $("button:eq("+i+")").attr('id');
  randomCommand = "ButtonC ("+randomButton+")";
*/
  allRadios= $("input[type='radio']");
  i = Math.floor( Math.random()*allRadios.length);
  
  randomRadioName = $("input[type='radio']:eq("+i+")").attr('name');
  radioButtons = $("input[type='radio'][name="+randomRadioName+"]");

  alert('Radio '+randomRadioName+radioButtons+' '+radioButtons.length);
// TODO why do we get this alert twice?

//dlog(randomCommand);
  //queueCommand(randomCommand);
}


// Dynamic scripting

function textFieldChanged(textFieldId) {
	value = escape(document.getElementById(textFieldId).value);
  queueCommand ('SetC ('+textFieldId+') "'+value+'"');
  console.log('textFieldChanged '+value);
}

function elementGotFocus(id) {
	console.log('element '+id+' got focus');
  focusedElementId = id;
}  

// constructors for script nodes associated with each webview
function ButtonScript(viewId) {
    this.viewId = viewId;
    this.onFocus = function () {elementGotFocus(viewId)};
    this.onClick = function () {queueCommand('ButtonC ('+viewId+')')};
}

--></script>

<body onload="javascript: init();" style="padding:0px; margin:0px">
<div id="viewTree"></div>
<div id="root"><div id="1"></div></div>
<div id="new"></div>
<div id="parking"></div>
<div id="receivedUpdates" style="visibility:hidden; border:solid; border-width:1px; padding:4px; border-color:red;" ></div>
</body> </html>
