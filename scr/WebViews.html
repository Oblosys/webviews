<!DOCTYPE HTML>
<html>
 <head>
  <title>WebViews prototype</title>
  <link href="scr/WebViews.css" rel="stylesheet" type="text/css" />

  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jquery/1.5.0/jquery.min.js"></script>
  <script type="text/javascript" src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.9/jquery-ui.min.js"></script>
 </head>

<script type="text/javascript"> <!--

//var debugging = true;
var debugging = false;

//var drawingViewTree = true;
var drawingViewTree = false;

// automatically send random commands for testing
//var sendingRandomCommands = true;
var sendingRandomCommands = false;

var autoRefresh = true;
//var autoRefresh = false;

// for easily setting a breakpoint in the move operation
function breakpointCheck() {
}

var xmlhttp;

var commandQueue = '';

var focusedElementId = '';

var timer;

$(document).ready(function(){
});

function init() {
  var path = (document.location.href.split('/'))[3];
  queueCommand('Init "'+path+'"');
  refresh();
}

function startRefreshTimer() {
	if (autoRefresh) {
		setRefreshTimer(1000);
  }
}

function dlog(message) {
  if (debugging)
    console.log(message);
}

function setRefreshTimer(ms) {  
	timer = setTimeout('refresh()',ms);
}


function stopRefreshTimer() {
	clearTimeout(timer);
}

function refresh() {
    queueCommand('Refresh');
    startRefreshTimer();
}

/* Obsolete comment:
   For text fields, we just register that they have changed and send them with
   the queue after the first editing operation. Otherwise, when editing a text field and then
   clicking on eg. a radio button generates a server event for the text edit, which causes
   the radiobutton event to get lost. Better would be to remember the exact mouse position and
   generate the event again after the text edit has been handled. Now, if the text edit causes
   disabling and or restructuring of the interface, edit events will be sent which make no
   sense. By checking if the element that receives the event is still in the view structure
   after the text edit has been handled, and that it has not been disabled, we can cover for
   most problematic situations.
*/

function escape(arg) {
	var result = '';
  for (var i = 0; i < arg.length; i++) {
	  if (arg[i] == '"')
      result += '\\"';
    else if (arg[i] == '\n')
      result += '\\n';
    else
      result += arg[i];
  }
  return result;
}

function textFieldChanged(textFieldId) {
	value = escape(document.getElementById(textFieldId).value);
  queueCommand ('SetC ('+textFieldId+') "'+value+'"');
  console.log('textFieldChanged '+value);
}

function elementGotFocus(id) {
	console.log('element '+id+' got focus');
  focusedElementId = id;
}  

function addCommand(command) {
	commandQueue = commandQueue + (commandQueue != '' ? ',' : '') + command;
} // add command to queue, and if queue was not empty, put a comma in front


var xmlhttp;

// TODO we don't want empty commands sent to server
function queueCommand(command) {
	if (command != '') addCommand(command);

  stopRefreshTimer(); // don't want auto refresh while waiting for results

  if ( xmlhttp && xmlhttp.readyState != 0 && xmlhttp.readyState != 4)
    return; // if xmlhttp exists and was initialized and not ready, we return
            // TODO: can readyState == 0 happen?  
             
  xmlhttp=null;
  if (window.XMLHttpRequest) {
	  // code for Firefox, Opera, IE7, etc.
    xmlhttp=new XMLHttpRequest();
  }
  else if (window.ActiveXObject) {
	  // code for IE6, IE5
    xmlhttp=new ActiveXObject("Microsoft.XMLHTTP");
  }
  if (xmlhttp!=null) {
	  xmlhttp.onreadystatechange=state_Change;
    xmlhttp.open("GET",'handle?commands=Commands ['+commandQueue+']',true);
    xmlhttp.send(null); // commands in commandQueue are already separated by commmas
    commandQueue = '';
  }
  else {
	  alert("Your browser does not support XMLHTTP.");
  }
}

/*
// tricky to do these as regular commands in the command queue.
function authenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'authenticate',true);
  xmlhttp.send(null);
}

function unauthenticate()
{ xmlhttp.onreadystatechange=state_Change;
  xmlhttp.open("GET",'unauthenticate',true);
  xmlhttp.send(null);
}
*/

function state_Change() {
	if (xmlhttp.readyState==4) {// 4 = "loaded"
  	if (xmlhttp.status==200) {// 200 = "OK"
	    dlog("received");
  	  var receivedUpdates = document.getElementById('receivedUpdates');
  	  receivedUpdates.innerHTML=xmlhttp.responseText;
      
   	  if (commandQueue != '') {
   		  dlog('sending queue');
        queueCommand('');
      }
        
    	var updates = document.getElementById('updates');
    	// getElementById seems to trigger parsing the responseText
    	// after this, firstChild has a value, while it is null before
    	// newRendering.firstChild;
    
   		// process all the updates from the server
   		while (updates.firstChild) {
   			updateTree( updates.firstChild );
        updates.removeChild(updates.firstChild);
      }

      if (drawingViewTree)
      drawViewTree();

      removeChildrenById("parking"); // clean any parked webnodes

      // restore focus
      dlog("restoring focus to "+focusedElementId);
      var focusedElement = document.getElementById(focusedElementId);
      if (focusedElement != null)
        focusedElement.focus();
      else
        dlog("failed");

//    $("[class='tabbed']").tabs(); // register tabbed views
//    $("[class='draggable']").draggable({refreshPositions: true});
//    $("[class='sortable']").draggable({refreshPositions: true});

/*  uncomment this for sortable hLists
 $(function() {
 $(".hList").disableSelection();
 $(".vList").disableSelection();

$(".hList").sortable({connectWith: '.vList, .hList'});
$(".vList").sortable({connectWith: '.vList, .hList'});
});
*/
      // start refresh timer again
      if (commandQueue == '') // only if command handling did not queue any new commands
        if (sendingRandomCommands)
          sendRandomCommand();
        else
          startRefreshTimer();
    }
    else { // xmlhttp.status!=200
      console.error("Problem retrieving data:" + xmlhttp.statusText);
    }
  } // no action if xmlhttp.readyState!=4
}

function updateTree(update) {
	var op = update.getAttribute('op');
 
  if (op === 'replace') {
	  var targetId = update.getAttribute('targetId');
    var newChild = update.childNodes[0];
    dlog("replace");
    dlog(commandQueue);
    
    var oldChild = document.getElementById(targetId);
    
    var parent = oldChild.parentNode;
    
    parent.replaceChild(newChild,oldChild);
  } 
  else if (op === 'special') { // used for trying out commands in a running WebView
	  var targetId = update.getAttribute('targetId');
    var newChild = update.childNodes[0];
    dlog("special"+commandQueue);

    var parking = document.getElementById("parking");
    var ther2 = document.getElementById("input11");
    var ther3 = document.getElementById("pigview15");
  
    //parking.appendChild(ther3);

    var oldChild = document.getElementById(targetId);  
    var parent = oldChild.parentNode;    
    parent.replaceChild(newChild,oldChild);

    var newwrong2 = document.getElementById("input111");
    var parentr2 = newwrong2.parentNode;    
    parentr2.replaceChild(ther2,newwrong2); // Note: old and new seem reversed (but are ok)

    var newwrong3 = document.getElementById("pigview115");
    var parentr3 = newwrong3.parentNode;    
    parentr3.replaceChild(ther3,newwrong3); // Note: old and new seem reversed (but are ok)

    focusedElementId = "radio122button0";
    dlog("restoring focus to "+focusedElementId);
    var focusedElement = document.getElementById(focusedElementId);
    if (focusedElement != null)
      focusedElement.focus();
    else
      dlog("failed");
    dlog ("end of special");
  }
  else if (op === 'exception') {
	  var text = update.getAttribute('text');
    sendingRandomCommands = false;
    autoRefresh = false;
    alert(text);
    init();
  }
  else if (op === 'alert') {
	  var text = update.getAttribute('text');
    if (!sendingRandomCommands)  // don't let dialogs interrupt auto command sequence
      alert(text);
  } 
  else if (op === 'confirm') {
	  var text = update.getAttribute('text');
    if (!sendingRandomCommands) { // don't let dialogs interrupt auto command sequence
      if (confirm(text))
        queueCommand('ConfirmDialogOk');
    }
    else
      queueCommand('ConfirmDialogOk');
  } 
  else if (op === 'authenticate') {
	  authenticate();
  } 
  else if (op === 'new') {
	  var newChild = update.childNodes[0];

    var newElts = document.getElementById('new');
    newElts.appendChild(newChild);
  }
  else if (op === 'move') {
	  var srcId = update.getAttribute('src');
    var dstId = update.getAttribute('dst');
    breakpointCheck();
    dlog("Moving "+srcId + " to " + dstId);
    srcElt = document.getElementById(srcId);
    dstElt = document.getElementById(dstId);

    if (srcElt && dstElt) {
    	parentElt = dstElt.parentNode;

      var parkingElt = document.getElementById('parking');
      parentElt.replaceChild(srcElt,dstElt);

//    parentElt.insertBefore(srcElt,dstElt);
      parkingElt.appendChild(dstElt);
    }
  }
  else if (op === 'eval') {
	  var scriptTxt = update.childNodes[0].data;
    //console.log("Evaluate:",scriptTxt)
    eval(scriptTxt);
  }
  else alert ('Unknown command: '+op); 
}

function select(path, node) {
	var step = path.firstChild;
  if (!step)
    return node;
  else {
	  path.removeChild(step);
    var childNr = parseInt( step.getAttribute('childNr') ); 
    var child = node.childNodes[childNr];
    return (select (path, child));
  }
}

function drawViewTree() {
	removeChildrenById("viewTree");    
  drawViewTreeElt('',document.getElementById('root'));
}

function drawViewTreeElt(indent, elt) {
	if (elt.id) draw(indent+elt.id+'<br/>');
  for (var i=0; i < elt.childNodes.length; i++)
    drawViewTreeElt(indent+  (elt.id ? '&nbsp;&nbsp;&nbsp;' : ''), elt.childNodes[i]);
}

function draw(str) {
	document.getElementById('viewTree').innerHTML+=str
}

function removeChildrenById(id) {
	removeChildren(document.getElementById(id));
}

function removeChildren(elt) {
	while (elt.firstChild)
    elt.removeChild(elt.firstChild);
}

function sendRandomCommand() {
	dlog("random command");
  /* allButtons = $("button");
  i = Math.floor( Math.random()*allButtons.length);
  
  randomButton = $("button:eq("+i+")").attr('id');
  randomCommand = "ButtonC ("+randomButton+")";
*/
  allRadios= $("input[type='radio']");
  i = Math.floor( Math.random()*allRadios.length);
  
  randomRadioName = $("input[type='radio']:eq("+i+")").attr('name');
  radioButtons = $("input[type='radio'][name="+randomRadioName+"]");

  alert('Radio '+randomRadioName+radioButtons+' '+radioButtons.length);
// TODO why do we get this alert twice?

//dlog(randomCommand);
  //queueCommand(randomCommand);
}
--></script>

<body onload="javascript: init();" style="padding:0px; margin:0px">
<div id="viewTree"></div>
<div id="root"><div id="1">Initial root</div></div>
<div id="new"></div>
<div id="parking"></div>
<div id="receivedUpdates" style="visibility:hidden; border:solid; border-width:1px; padding:4px; border-color:red;" ></div>
</body> </html>
